name: Kernel Build Validation

on:
  pull_request:
    paths:
      - 'robocache/setup.py'
      - 'robocache/csrc/**'
      - 'robocache/kernels/**'
      - '.github/workflows/kernel_build_validation.yml'
  push:
    branches: [main]
    paths:
      - 'robocache/setup.py'
      - 'robocache/csrc/**'
      - 'robocache/kernels/**'
  workflow_dispatch:

# Validates that all CUDA extensions compile and are importable
jobs:
  build-and-verify:
    name: Build & Verify Kernels
    runs-on: ubuntu-latest
    
    # Use NVIDIA CUDA container for reproducible builds
    container:
      image: nvcr.io/nvidia/pytorch:24.09-py3
      options: --gpus all
    
    env:
      TORCH_CUDA_ARCH_LIST: "8.0;9.0"  # A100 (SM80) + H100 (SM90)
      CUDA_HOME: /usr/local/cuda
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: System Info
        run: |
          echo "=== CUDA Environment ==="
          nvcc --version
          python3 --version
          pip list | grep torch
          echo "CUDA_HOME: $CUDA_HOME"
          echo "TORCH_CUDA_ARCH_LIST: $TORCH_CUDA_ARCH_LIST"
          nvidia-smi || echo "nvidia-smi not available (expected in CI)"
      
      - name: Build CUDA Extensions
        id: build
        run: |
          cd ${{ github.workspace }}/robocache
          
          echo "=== Building RoboCache CUDA Extensions ==="
          python3 setup.py build_ext --inplace 2>&1 | tee build.log
          
          # Check for build success
          if [ $? -ne 0 ]; then
            echo "❌ Build failed"
            cat build.log
            exit 1
          fi
          
          echo "✅ Build completed"
          
          # Verify .so files exist
          echo ""
          echo "=== Verifying .so Files ==="
          ls -lh python/robocache/*.so || (echo "❌ No .so files found" && exit 1)
          
          SO_COUNT=$(ls python/robocache/*.so 2>/dev/null | wc -l)
          echo "Found $SO_COUNT extension(s)"
          
          if [ "$SO_COUNT" -lt 4 ]; then
            echo "❌ Expected 4 extensions, found $SO_COUNT"
            echo "Missing extensions:"
            ls python/robocache/ | grep -v "\.so"
            exit 1
          fi
          
          echo "✅ All 4 extensions built"
      
      - name: Verify Extension Imports
        id: imports
        run: |
          cd ${{ github.workspace }}/robocache/python
          
          echo "=== Testing Extension Imports ==="
          
          # Set LD_LIBRARY_PATH for PyTorch libs
          export LD_LIBRARY_PATH=$(python3 -c "import torch, os; print(os.path.join(os.path.dirname(torch.__file__), 'lib'))"):$LD_LIBRARY_PATH
          
          python3 << 'EOF'
          import sys
          sys.path.insert(0, '.')
          
          extensions = {
              '_cuda_ops': ['resample_kernel_wrapper'],
              '_multimodal_ops': ['fuse_multimodal_kernel'],
              '_voxelize_ops': ['voxelize_count', 'voxelize_occupancy'],
              '_cutlass_ops': ['resample_trajectories_cutlass']
          }
          
          print("\n=== Import Verification ===")
          
          failed = []
          for ext_name, expected_funcs in extensions.items():
              try:
                  # Import the extension
                  exec(f"import robocache.{ext_name} as ext")
                  funcs = [f for f in dir(eval('ext')) if not f.startswith('_')]
                  
                  print(f"\n✅ {ext_name}:")
                  print(f"   Functions: {', '.join(funcs)}")
                  
                  # Check expected functions exist
                  missing = [f for f in expected_funcs if f not in funcs]
                  if missing:
                      print(f"   ⚠️  Missing: {', '.join(missing)}")
                  
              except Exception as e:
                  print(f"\n❌ {ext_name}: IMPORT FAILED")
                  print(f"   Error: {e}")
                  failed.append(ext_name)
          
          if failed:
              print(f"\n❌ Failed to import: {', '.join(failed)}")
              sys.exit(1)
          
          print("\n✅ All extensions imported successfully")
          EOF
      
      - name: Test Kernel Functionality
        id: functional
        run: |
          cd ${{ github.workspace }}/robocache/python
          
          export LD_LIBRARY_PATH=$(python3 -c "import torch, os; print(os.path.join(os.path.dirname(torch.__file__), 'lib'))"):$LD_LIBRARY_PATH
          
          echo "=== Functional Tests ==="
          
          python3 << 'EOF'
          import sys
          sys.path.insert(0, '.')
          import torch
          import robocache
          
          # Quick smoke test for each operation
          print("\n=== Testing Core Operations ===")
          
          # 1. Trajectory Resampling
          print("\n1. Trajectory Resampling...")
          src = torch.randn(2, 10, 8, device='cuda', dtype=torch.bfloat16)
          src_t = torch.linspace(0, 1, 10, device='cuda').unsqueeze(0).expand(2, -1)
          tgt_t = torch.linspace(0, 1, 20, device='cuda').unsqueeze(0).expand(2, -1)
          result = robocache.resample_trajectories(src, src_t, tgt_t)
          assert result.shape == (2, 20, 8), f"Wrong shape: {result.shape}"
          print("   ✅ PASS")
          
          # 2. Multimodal Fusion
          print("\n2. Multimodal Fusion...")
          v = torch.randn(2, 10, 16, device='cuda', dtype=torch.bfloat16)
          v_t = torch.linspace(0, 1, 10, device='cuda').unsqueeze(0).expand(2, -1)
          p = torch.randn(2, 20, 8, device='cuda', dtype=torch.bfloat16)
          p_t = torch.linspace(0, 1, 20, device='cuda').unsqueeze(0).expand(2, -1)
          i = torch.randn(2, 30, 4, device='cuda', dtype=torch.bfloat16)
          i_t = torch.linspace(0, 1, 30, device='cuda').unsqueeze(0).expand(2, -1)
          tgt = torch.linspace(0, 1, 15, device='cuda').unsqueeze(0).expand(2, -1)
          result = robocache.fuse_multimodal(v, v_t, p, p_t, i, i_t, tgt)
          assert result.shape == (2, 15, 28), f"Wrong shape: {result.shape}"
          print("   ✅ PASS")
          
          # 3. Voxelization
          print("\n3. Voxelization...")
          points = torch.rand(1000, 3, device='cuda') * 4.0 - 2.0
          grid = robocache.voxelize_pointcloud(
              points,
              grid_min=[-2.0, -2.0, -2.0],
              voxel_size=0.1,
              grid_size=[64, 64, 64],
              mode='occupancy'
          )
          assert grid.shape == (64, 64, 64), f"Wrong shape: {grid.shape}"
          print("   ✅ PASS")
          
          # 4. CUTLASS (if available)
          print("\n4. CUTLASS Kernel...")
          try:
              import robocache._cutlass_ops as cutlass
              src = torch.randn(2, 10, 8, device='cuda', dtype=torch.bfloat16)
              src_t = torch.linspace(0, 1, 10, device='cuda').unsqueeze(0).expand(2, -1)
              tgt_t = torch.linspace(0, 1, 20, device='cuda').unsqueeze(0).expand(2, -1)
              result = cutlass.resample_trajectories_cutlass(src, src_t, tgt_t)
              assert result.shape == (2, 20, 8), f"Wrong shape: {result.shape}"
              print("   ✅ PASS")
          except Exception as e:
              print(f"   ⚠️  CUTLASS test skipped: {e}")
          
          print("\n✅ All functional tests passed")
          EOF
      
      - name: Create Validation Report
        if: always()
        run: |
          cat > ${{ github.workspace }}/kernel_validation_report.md << 'EOF'
          # Kernel Build Validation Report
          
          **Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Commit:** ${{ github.sha }}
          **Workflow:** ${{ github.workflow }} #${{ github.run_number }}
          
          ## Summary
          
          - **Build:** ${{ steps.build.outcome }}
          - **Imports:** ${{ steps.imports.outcome }}
          - **Functional Tests:** ${{ steps.functional.outcome }}
          
          ## Extensions Validated
          
          - `robocache._cuda_ops` - Reference trajectory resampling
          - `robocache._multimodal_ops` - Reference multimodal fusion
          - `robocache._voxelize_ops` - Reference voxelization
          - `robocache._cutlass_ops` - CUTLASS-optimized trajectory resampling
          
          ## Build Configuration
          
          - **CUDA Architectures:** SM80 (A100), SM90 (H100)
          - **Container:** nvcr.io/nvidia/pytorch:24.09-py3
          - **PyTorch:** $(python3 -c "import torch; print(torch.__version__)")
          - **CUDA:** $(nvcc --version | grep "release" | awk '{print $5}' | tr -d ',')
          
          ## Status
          
          ✅ All kernels build and pass basic functional tests.
          EOF
          
          cat ${{ github.workspace }}/kernel_validation_report.md
      
      - name: Upload Validation Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: kernel-validation-report
          path: ${{ github.workspace }}/kernel_validation_report.md
          retention-days: 90
      
      - name: Fail if validation failed
        if: steps.build.outcome != 'success' || steps.imports.outcome != 'success' || steps.functional.outcome != 'success'
        run: |
          echo "❌ Kernel validation failed"
          echo "Build: ${{ steps.build.outcome }}"
          echo "Imports: ${{ steps.imports.outcome }}"
          echo "Functional: ${{ steps.functional.outcome }}"
          exit 1

